# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *

class matlabGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def file_(self, parent=None):
        with RuleContext(self, UnparserRule(name='file_', parent=parent)) as current:
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.statement_list(parent=current)
            self.EOF(parent=current)
            return current
    file_.min_depth = 1

    def primary_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='primary_expression', parent=parent)) as current:
            with AlternationContext(self, [1, 2, 1, 10, 0, 4], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.IDENTIFIER(parent=current)
                elif choice0 == 1:
                    self.CONSTANT(parent=current)
                elif choice0 == 2:
                    self.STRING_LITERAL(parent=current)
                elif choice0 == 3:
                    UnlexerRule(src='(', parent=current)
                    self.expression(parent=current)
                    UnlexerRule(src=')', parent=current)
                elif choice0 == 4:
                    UnlexerRule(src='[', parent=current)
                    UnlexerRule(src=']', parent=current)
                elif choice0 == 5:
                    UnlexerRule(src='[', parent=current)
                    self.array_list(parent=current)
                    UnlexerRule(src=']', parent=current)
            return current
    primary_expression.min_depth = 0

    def postfix_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='postfix_expression', parent=parent)) as current:
            with AlternationContext(self, [1, 3, 2, 2], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.primary_expression(parent=current)
                elif choice0 == 1:
                    self.array_expression(parent=current)
                elif choice0 == 2:
                    self.postfix_expression(parent=current)
                    self.TRANSPOSE(parent=current)
                elif choice0 == 3:
                    self.postfix_expression(parent=current)
                    self.NCTRANSPOSE(parent=current)
            return current
    postfix_expression.min_depth = 1

    def index_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='index_expression', parent=parent)) as current:
            with AlternationContext(self, [0, 10], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [':', None][choice0]
                rule = [None, self.expression][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    index_expression.min_depth = 0

    def index_expression_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='index_expression_list', parent=parent)) as current:
            with AlternationContext(self, [1, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.index_expression(parent=current)
                elif choice0 == 1:
                    self.index_expression_list(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.index_expression(parent=current)
            return current
    index_expression_list.min_depth = 1

    def array_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='array_expression', parent=parent)) as current:
            self.IDENTIFIER(parent=current)
            UnlexerRule(src='(', parent=current)
            self.index_expression_list(parent=current)
            UnlexerRule(src=')', parent=current)
            return current
    array_expression.min_depth = 2

    def unary_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='unary_expression', parent=parent)) as current:
            with AlternationContext(self, [2, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.postfix_expression(parent=current)
                elif choice0 == 1:
                    self.unary_operator(parent=current)
                    self.postfix_expression(parent=current)
            return current
    unary_expression.min_depth = 2

    def unary_operator(self, parent=None):
        with RuleContext(self, UnparserRule(name='unary_operator', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['+', '-', '~'][choice0], parent=current)
            return current
    unary_operator.min_depth = 0

    def multiplicative_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='multiplicative_expression', parent=parent)) as current:
            with AlternationContext(self, [3, 4, 4, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.unary_expression(parent=current)
                elif choice0 == 1:
                    self.multiplicative_expression(parent=current)
                    UnlexerRule(src='*', parent=current)
                    self.unary_expression(parent=current)
                elif choice0 == 2:
                    self.multiplicative_expression(parent=current)
                    UnlexerRule(src='/', parent=current)
                    self.unary_expression(parent=current)
                elif choice0 == 3:
                    self.multiplicative_expression(parent=current)
                    UnlexerRule(src='\\', parent=current)
                    self.unary_expression(parent=current)
                elif choice0 == 4:
                    self.multiplicative_expression(parent=current)
                    UnlexerRule(src='^', parent=current)
                    self.unary_expression(parent=current)
                elif choice0 == 5:
                    self.multiplicative_expression(parent=current)
                    self.ARRAYMUL(parent=current)
                    self.unary_expression(parent=current)
                elif choice0 == 6:
                    self.multiplicative_expression(parent=current)
                    self.ARRAYDIV(parent=current)
                    self.unary_expression(parent=current)
                elif choice0 == 7:
                    self.multiplicative_expression(parent=current)
                    self.ARRAYRDIV(parent=current)
                    self.unary_expression(parent=current)
                elif choice0 == 8:
                    self.multiplicative_expression(parent=current)
                    self.ARRAYPOW(parent=current)
                    self.unary_expression(parent=current)
            return current
    multiplicative_expression.min_depth = 3

    def additive_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='additive_expression', parent=parent)) as current:
            with AlternationContext(self, [4, 5, 5], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.multiplicative_expression(parent=current)
                elif choice0 == 1:
                    self.additive_expression(parent=current)
                    UnlexerRule(src='+', parent=current)
                    self.multiplicative_expression(parent=current)
                elif choice0 == 2:
                    self.additive_expression(parent=current)
                    UnlexerRule(src='-', parent=current)
                    self.multiplicative_expression(parent=current)
            return current
    additive_expression.min_depth = 4

    def relational_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='relational_expression', parent=parent)) as current:
            with AlternationContext(self, [5, 6, 6, 6, 6], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.additive_expression(parent=current)
                elif choice0 == 1:
                    self.relational_expression(parent=current)
                    UnlexerRule(src='<', parent=current)
                    self.additive_expression(parent=current)
                elif choice0 == 2:
                    self.relational_expression(parent=current)
                    UnlexerRule(src='>', parent=current)
                    self.additive_expression(parent=current)
                elif choice0 == 3:
                    self.relational_expression(parent=current)
                    self.LE_OP(parent=current)
                    self.additive_expression(parent=current)
                elif choice0 == 4:
                    self.relational_expression(parent=current)
                    self.GE_OP(parent=current)
                    self.additive_expression(parent=current)
            return current
    relational_expression.min_depth = 5

    def equality_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='equality_expression', parent=parent)) as current:
            with AlternationContext(self, [6, 7, 7], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.relational_expression(parent=current)
                elif choice0 == 1:
                    self.equality_expression(parent=current)
                    self.EQ_OP(parent=current)
                    self.relational_expression(parent=current)
                elif choice0 == 2:
                    self.equality_expression(parent=current)
                    self.NE_OP(parent=current)
                    self.relational_expression(parent=current)
            return current
    equality_expression.min_depth = 6

    def and_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='and_expression', parent=parent)) as current:
            with AlternationContext(self, [7, 8], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.equality_expression(parent=current)
                elif choice0 == 1:
                    self.and_expression(parent=current)
                    UnlexerRule(src='&', parent=current)
                    self.equality_expression(parent=current)
            return current
    and_expression.min_depth = 7

    def or_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='or_expression', parent=parent)) as current:
            with AlternationContext(self, [8, 9], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.and_expression(parent=current)
                elif choice0 == 1:
                    self.or_expression(parent=current)
                    UnlexerRule(src='|', parent=current)
                    self.and_expression(parent=current)
            return current
    or_expression.min_depth = 8

    def expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='expression', parent=parent)) as current:
            with AlternationContext(self, [9, 10], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.or_expression(parent=current)
                elif choice0 == 1:
                    self.expression(parent=current)
                    UnlexerRule(src=':', parent=current)
                    self.or_expression(parent=current)
            return current
    expression.min_depth = 9

    def assignment_expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='assignment_expression', parent=parent)) as current:
            self.postfix_expression(parent=current)
            UnlexerRule(src='=', parent=current)
            self.expression(parent=current)
            return current
    assignment_expression.min_depth = 10

    def eostmt(self, parent=None):
        with RuleContext(self, UnparserRule(name='eostmt', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 1], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [',', ';', None][choice0]
                rule = [None, None, self.CR][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    eostmt.min_depth = 0

    def statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='statement', parent=parent)) as current:
            with AlternationContext(self, [3, 3, 12, 2, 11, 11, 2], [1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.global_statement, self.clear_statement, self.assignment_statement, self.expression_statement, self.selection_statement, self.iteration_statement, self.jump_statement][choice0](parent=current)
            return current
    statement.min_depth = 2

    def statement_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='statement_list', parent=parent)) as current:
            with AlternationContext(self, [3, 4], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.statement(parent=current)
                elif choice0 == 1:
                    self.statement_list(parent=current)
                    self.statement(parent=current)
            return current
    statement_list.min_depth = 3

    def identifier_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='identifier_list', parent=parent)) as current:
            with AlternationContext(self, [1, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.IDENTIFIER(parent=current)
                elif choice0 == 1:
                    self.identifier_list(parent=current)
                    self.IDENTIFIER(parent=current)
            return current
    identifier_list.min_depth = 1

    def global_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='global_statement', parent=parent)) as current:
            self.GLOBAL(parent=current)
            self.identifier_list(parent=current)
            self.eostmt(parent=current)
            return current
    global_statement.min_depth = 2

    def clear_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='clear_statement', parent=parent)) as current:
            self.CLEAR(parent=current)
            self.identifier_list(parent=current)
            self.eostmt(parent=current)
            return current
    clear_statement.min_depth = 2

    def expression_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='expression_statement', parent=parent)) as current:
            with AlternationContext(self, [1, 10], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.eostmt(parent=current)
                elif choice0 == 1:
                    self.expression(parent=current)
                    self.eostmt(parent=current)
            return current
    expression_statement.min_depth = 1

    def assignment_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='assignment_statement', parent=parent)) as current:
            self.assignment_expression(parent=current)
            self.eostmt(parent=current)
            return current
    assignment_statement.min_depth = 11

    def array_element(self, parent=None):
        with RuleContext(self, UnparserRule(name='array_element', parent=parent)) as current:
            with AlternationContext(self, [10, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.expression, self.expression_statement][choice0](parent=current)
            return current
    array_element.min_depth = 2

    def array_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='array_list', parent=parent)) as current:
            with AlternationContext(self, [3, 4], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.array_element(parent=current)
                elif choice0 == 1:
                    self.array_list(parent=current)
                    self.array_element(parent=current)
            return current
    array_list.min_depth = 3

    def selection_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='selection_statement', parent=parent)) as current:
            with AlternationContext(self, [10, 10, 11, 11], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.IF(parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
                    self.END(parent=current)
                    self.eostmt(parent=current)
                elif choice0 == 1:
                    self.IF(parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
                    self.ELSE(parent=current)
                    self.statement_list(parent=current)
                    self.END(parent=current)
                    self.eostmt(parent=current)
                elif choice0 == 2:
                    self.IF(parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
                    self.elseif_clause(parent=current)
                    self.END(parent=current)
                    self.eostmt(parent=current)
                elif choice0 == 3:
                    self.IF(parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
                    self.elseif_clause(parent=current)
                    self.ELSE(parent=current)
                    self.statement_list(parent=current)
                    self.END(parent=current)
                    self.eostmt(parent=current)
            return current
    selection_statement.min_depth = 10

    def elseif_clause(self, parent=None):
        with RuleContext(self, UnparserRule(name='elseif_clause', parent=parent)) as current:
            with AlternationContext(self, [10, 11], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.ELSEIF(parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
                elif choice0 == 1:
                    self.elseif_clause(parent=current)
                    self.ELSEIF(parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
            return current
    elseif_clause.min_depth = 10

    def iteration_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='iteration_statement', parent=parent)) as current:
            with AlternationContext(self, [10, 10, 10], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.WHILE(parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
                    self.END(parent=current)
                    self.eostmt(parent=current)
                elif choice0 == 1:
                    self.FOR(parent=current)
                    self.IDENTIFIER(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.expression(parent=current)
                    self.statement_list(parent=current)
                    self.END(parent=current)
                    self.eostmt(parent=current)
                elif choice0 == 2:
                    self.FOR(parent=current)
                    UnlexerRule(src='(', parent=current)
                    self.IDENTIFIER(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.expression(parent=current)
                    UnlexerRule(src=')', parent=current)
                    self.statement_list(parent=current)
                    self.END(parent=current)
                    self.eostmt(parent=current)
            return current
    iteration_statement.min_depth = 10

    def jump_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='jump_statement', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.BREAK(parent=current)
                    self.eostmt(parent=current)
                elif choice0 == 1:
                    self.RETURN(parent=current)
                    self.eostmt(parent=current)
            return current
    jump_statement.min_depth = 1

    def translation_unit(self, parent=None):
        with RuleContext(self, UnparserRule(name='translation_unit', parent=parent)) as current:
            with AlternationContext(self, [4, 4], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.statement_list(parent=current)
                elif choice0 == 1:
                    self.FUNCTION(parent=current)
                    self.function_declare(parent=current)
                    self.eostmt(parent=current)
                    self.statement_list(parent=current)
            return current
    translation_unit.min_depth = 4

    def func_ident_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='func_ident_list', parent=parent)) as current:
            with AlternationContext(self, [1, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.IDENTIFIER(parent=current)
                elif choice0 == 1:
                    self.func_ident_list(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.IDENTIFIER(parent=current)
            return current
    func_ident_list.min_depth = 1

    def func_return_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='func_return_list', parent=parent)) as current:
            with AlternationContext(self, [1, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.IDENTIFIER(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='[', parent=current)
                    self.func_ident_list(parent=current)
                    UnlexerRule(src=']', parent=current)
            return current
    func_return_list.min_depth = 1

    def function_declare_lhs(self, parent=None):
        with RuleContext(self, UnparserRule(name='function_declare_lhs', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.IDENTIFIER(parent=current)
                elif choice0 == 1:
                    self.IDENTIFIER(parent=current)
                    UnlexerRule(src='(', parent=current)
                    UnlexerRule(src=')', parent=current)
                elif choice0 == 2:
                    self.IDENTIFIER(parent=current)
                    UnlexerRule(src='(', parent=current)
                    self.func_ident_list(parent=current)
                    UnlexerRule(src=')', parent=current)
            return current
    function_declare_lhs.min_depth = 1

    def function_declare(self, parent=None):
        with RuleContext(self, UnparserRule(name='function_declare', parent=parent)) as current:
            with AlternationContext(self, [2, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.function_declare_lhs(parent=current)
                elif choice0 == 1:
                    self.func_return_list(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.function_declare_lhs(parent=current)
            return current
    function_declare.min_depth = 2

    def ARRAYMUL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ARRAYMUL', parent=parent)) as current:
            UnlexerRule(src='.*', parent=current)
            return current
    ARRAYMUL.min_depth = 0

    def ARRAYDIV(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ARRAYDIV', parent=parent)) as current:
            UnlexerRule(src='.\\', parent=current)
            return current
    ARRAYDIV.min_depth = 0

    def ARRAYRDIV(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ARRAYRDIV', parent=parent)) as current:
            UnlexerRule(src='./', parent=current)
            return current
    ARRAYRDIV.min_depth = 0

    def ARRAYPOW(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ARRAYPOW', parent=parent)) as current:
            UnlexerRule(src='.^', parent=current)
            return current
    ARRAYPOW.min_depth = 0

    def BREAK(self, parent=None):
        with RuleContext(self, UnlexerRule(name='BREAK', parent=parent)) as current:
            UnlexerRule(src='break', parent=current)
            return current
    BREAK.min_depth = 0

    def RETURN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RETURN', parent=parent)) as current:
            UnlexerRule(src='return', parent=current)
            return current
    RETURN.min_depth = 0

    def FUNCTION(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FUNCTION', parent=parent)) as current:
            UnlexerRule(src='function', parent=current)
            return current
    FUNCTION.min_depth = 0

    def FOR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FOR', parent=parent)) as current:
            UnlexerRule(src='for', parent=current)
            return current
    FOR.min_depth = 0

    def WHILE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WHILE', parent=parent)) as current:
            UnlexerRule(src='while', parent=current)
            return current
    WHILE.min_depth = 0

    def END(self, parent=None):
        with RuleContext(self, UnlexerRule(name='END', parent=parent)) as current:
            UnlexerRule(src='end', parent=current)
            return current
    END.min_depth = 0

    def GLOBAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='GLOBAL', parent=parent)) as current:
            UnlexerRule(src='global', parent=current)
            return current
    GLOBAL.min_depth = 0

    def IF(self, parent=None):
        with RuleContext(self, UnlexerRule(name='IF', parent=parent)) as current:
            UnlexerRule(src='if', parent=current)
            return current
    IF.min_depth = 0

    def CLEAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CLEAR', parent=parent)) as current:
            UnlexerRule(src='clear', parent=current)
            return current
    CLEAR.min_depth = 0

    def ELSE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ELSE', parent=parent)) as current:
            UnlexerRule(src='else', parent=current)
            return current
    ELSE.min_depth = 0

    def ELSEIF(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ELSEIF', parent=parent)) as current:
            UnlexerRule(src='elseif', parent=current)
            return current
    ELSEIF.min_depth = 0

    def LE_OP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LE_OP', parent=parent)) as current:
            UnlexerRule(src='<=', parent=current)
            return current
    LE_OP.min_depth = 0

    def GE_OP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='GE_OP', parent=parent)) as current:
            UnlexerRule(src='>=', parent=current)
            return current
    GE_OP.min_depth = 0

    def EQ_OP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EQ_OP', parent=parent)) as current:
            UnlexerRule(src='==', parent=current)
            return current
    EQ_OP.min_depth = 0

    def NE_OP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NE_OP', parent=parent)) as current:
            UnlexerRule(src='~=', parent=current)
            return current
    NE_OP.min_depth = 0

    def TRANSPOSE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='TRANSPOSE', parent=parent)) as current:
            UnlexerRule(src='transpose', parent=current)
            return current
    TRANSPOSE.min_depth = 0

    def NCTRANSPOSE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NCTRANSPOSE', parent=parent)) as current:
            UnlexerRule(src='.\'', parent=current)
            return current
    NCTRANSPOSE.min_depth = 0

    def STRING_LITERAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='STRING_LITERAL', parent=parent)) as current:
            UnlexerRule(src='\'', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src='\'\'', parent=current)
            UnlexerRule(src='\'', parent=current)
            return current
    STRING_LITERAL.min_depth = 0

    def IDENTIFIER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='IDENTIFIER', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[2]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[3]), parent=current)
            return current
    IDENTIFIER.min_depth = 0

    def CONSTANT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CONSTANT', parent=parent)) as current:
            self.NUMBER(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.E(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.SIGN(parent=current)
                    self.NUMBER(parent=current)
            return current
    CONSTANT.min_depth = 1

    def NUMBER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NUMBER', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[4]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 2, min=1, max=inf):
                            UnlexerRule(src=self._model.charset(current, 1, self._charsets[5]), parent=current)
            return current
    NUMBER.min_depth = 0

    def E(self, parent=None):
        with RuleContext(self, UnlexerRule(name='E', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['E', 'e'][choice0], parent=current)
            return current
    E.min_depth = 0

    def SIGN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SIGN', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['+', '-'][choice0], parent=current)
            return current
    SIGN.min_depth = 0

    def CR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CR', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[6]), parent=current)
            return current
    CR.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[7]), parent=current)
            return current
    WS.min_depth = 0

    _default_rule = file_

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(32, 39), range(40, 127)])),
        2: list(itertools.chain.from_iterable([range(65, 91), range(97, 123)])),
        3: list(itertools.chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        4: list(itertools.chain.from_iterable([range(48, 58)])),
        5: list(itertools.chain.from_iterable([range(48, 58)])),
        6: list(itertools.chain.from_iterable([range(10, 11), range(13, 14)])),
        7: list(itertools.chain.from_iterable([range(9, 10), range(32, 33)])),
    }
